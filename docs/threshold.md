# Threshold Signing

## Overview

Threshold Lamport signing combines Multi-Party Computation (MPC) with Lamport one-time signatures to enable:

1. **Distributed Key Control**: T-of-N parties must cooperate to sign
2. **Automatic Key Rotation**: Next key committed in each signature
3. **On-Chain Simplicity**: Contract sees standard Lamport signature

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    T-Chain (MPC Layer)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  Party 1  │  │  Party 2  │  │  Party 3  │  ...       │
│  │ (share 1) │  │ (share 2) │  │ (share 3) │            │
│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘            │
│        └──────────────┼──────────────┘                  │
│                       ▼                                  │
│              ┌─────────────────┐                        │
│              │  MPC Protocol   │                        │
│              │ (Threshold Sign) │                        │
│              └────────┬────────┘                        │
│                       ▼                                  │
│              ┌─────────────────┐                        │
│              │ Lamport Keypair │ ← Generated by MPC     │
│              │   (ephemeral)   │                        │
│              └────────┬────────┘                        │
└───────────────────────┼─────────────────────────────────┘
                        ▼
┌───────────────────────────────────────────────────────┐
│                  C-Chain (EVM Layer)                   │
│  ┌─────────────────────────────────────────────────┐  │
│  │            LamportSafeModule                     │  │
│  │  ┌─────────────────┐  ┌───────────────────────┐ │  │
│  │  │   Current PKH   │  │  Verify Signature     │ │  │
│  │  │   (32 bytes)    │  │  Rotate to Next PKH   │ │  │
│  │  └─────────────────┘  └───────────────────────┘ │  │
│  └─────────────────────────────────────────────────┘  │
│                          ▼                             │
│  ┌─────────────────────────────────────────────────┐  │
│  │              Gnosis Safe Wallet                  │  │
│  └─────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────┘
```

## Key Generation

### Initial Setup

```go
// Each party generates share of first keypair
func InitializeThreshold(t, n int) (*ThresholdSetup, error) {
    // Generate shares using Shamir Secret Sharing
    shares := make([]*primitives.KeyShare, n)
    for i := 0; i < n; i++ {
        shares[i] = generateKeyShare(i, t, n)
    }

    // Compute public key from shares (no private key reconstruction)
    publicKey := combinePublicShares(shares)

    return &ThresholdSetup{
        Threshold: t,
        Total:     n,
        Shares:    shares,
        PublicKey: publicKey,
        PKH:       primitives.ComputePKH(publicKey),
    }, nil
}
```

### Key Rotation

Each signature includes commitment to next key:

```go
type SignRequest struct {
    Message    [32]byte            // Transaction hash
    CurrentKey primitives.PublicKey
    NextKey    primitives.PublicKey  // Pre-generated next key
}

func (ts *ThresholdSigner) Sign(req SignRequest) (*SignResult, error) {
    // Compute domain-separated message
    message := ComputeThresholdMessage(
        req.Message,
        primitives.ComputePKH(req.NextKey),
        ts.moduleAddress,
        ts.chainID,
    )

    // Threshold sign with T parties
    signature, err := ts.thresholdSign(message, req.CurrentKey)
    if err != nil {
        return nil, err
    }

    // Rotate to next key
    ts.currentKey = req.NextKey
    ts.prepareNextKey()

    return &SignResult{
        Signature:    signature,
        NextPKH:      primitives.ComputePKH(req.NextKey),
        NextPublicKey: req.NextKey,
    }, nil
}
```

## On-Chain Verification

```solidity
contract ThresholdLamportModule {
    bytes32 public currentPKH;

    function executeTransaction(
        bytes32 safeTxHash,
        bytes32[] calldata sig,
        bytes32[2][256] calldata currentPub,
        bytes32[2][256] calldata nextPub
    ) external {
        // 1. Verify current PKH
        require(
            LamportLib.computePKH(currentPub) == currentPKH,
            "Invalid current key"
        );

        // 2. Compute domain-separated message
        uint256 message = LamportLib.computeThresholdMessage(
            safeTxHash,
            LamportLib.computePKH(nextPub),
            address(this),
            block.chainid
        );

        // 3. Verify signature
        require(
            LamportLib.verify(bytes32(message), sig, currentPub),
            "Invalid signature"
        );

        // 4. Rotate to next key
        currentPKH = LamportLib.computePKH(nextPub);

        // 5. Execute transaction...
    }
}
```

## Security Considerations

### Threshold Properties

| Property | Guarantee |
|----------|-----------|
| Signing | Requires T-of-N parties |
| Key Recovery | Impossible with < T parties |
| Quantum Resistance | Lamport provides PQ security |

### Attack Vectors

1. **Key Reuse**: Prevented by atomic rotation in each signature
2. **Replay Attack**: Domain separation includes module address and chain ID
3. **Front-running**: Transaction can only execute with valid signature
4. **Party Compromise**: T-1 compromised parties cannot sign

### Operational Security

1. **Geographically Distributed Parties**: Reduces physical attack surface
2. **Hardware Security Modules**: Store key shares in HSMs
3. **Audit Logging**: Track all signing operations
4. **Emergency Recovery**: Pre-signed key rotation in case of party loss

## MPC Protocol

### Signing Protocol (Simplified)

```
Round 1: Share Commitment
- Each party commits to their contribution
- Broadcast commitments

Round 2: Share Reveal
- Each party reveals shares
- Verify against commitments

Round 3: Combine
- Combine T shares to reconstruct preimages
- Generate Lamport signature
```

### Key Share Storage

```go
type KeyShare struct {
    PartyID    int
    Threshold  int
    Total      int
    PrivShares [256][2]*big.Int  // Secret shares for each preimage
    PubKey     primitives.PublicKey
}
```

## Integration with Safe

### Module Deployment

```solidity
// Deploy module with initial PKH
ThresholdLamportModule module = new ThresholdLamportModule(
    safeAddress,
    initialPKH
);

// Enable module on Safe
safe.enableModule(address(module));
```

### Transaction Flow

1. **Propose**: User submits transaction to T-Chain
2. **Collect**: T parties approve and contribute signatures
3. **Combine**: MPC combines shares into Lamport signature
4. **Execute**: Submit signature to C-Chain module
5. **Rotate**: Module updates to next PKH

## API Reference

### ThresholdConfig

```go
type ThresholdConfig struct {
    Threshold    int              // T (minimum parties)
    TotalParties int              // N (total parties)
    ModuleAddr   common.Address   // On-chain module address
    ChainID      *big.Int         // Chain ID for domain separation
    KeyBundle    *KeyBundle       // Pre-generated key pairs
}

func (c *ThresholdConfig) ComputeMessage(
    safeTxHash [32]byte,
    nextPKH [32]byte,
) *big.Int {
    return LamportLib.ComputeThresholdMessage(
        safeTxHash,
        nextPKH,
        c.ModuleAddr,
        c.ChainID,
    )
}
```

### KeyBundle

```go
type KeyBundle struct {
    Current *primitives.Keypair
    Next    *primitives.Keypair
    Pool    []*primitives.Keypair  // Pre-generated keys
}

func (kb *KeyBundle) Rotate() {
    kb.Current = kb.Next
    kb.Next = kb.Pool[0]
    kb.Pool = kb.Pool[1:]
    kb.replenishPool()
}
```

## References

- [LP-4105](https://github.com/luxfi/lps) - Lamport OTS for Lux Safe
- [Shamir Secret Sharing](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing)
- [Threshold ECDSA](https://eprint.iacr.org/2020/540) - For comparison
- [Gnosis Safe](https://github.com/safe-global/safe-smart-account) - Safe contracts
